# generated by datamodel-codegen:
#   filename:  openspec.yml
#   timestamp: 2024-07-30T17:00:26+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional, TypedDict, Union
from typing_extensions import NotRequired

from pydantic import BaseModel, Field


class V1LoadResultAnnotation(BaseModel):
    measures: Dict[str, Any]
    dimensions: Dict[str, Any]
    segments: Dict[str, Any]
    timeDimensions: Dict[str, Any]


class V1LoadResult(BaseModel):
    dataSource: Optional[str] = None
    annotation: V1LoadResultAnnotation
    data: List[Dict[str, str]]


class V1LoadResponse(BaseModel):
    pivotQuery: Optional[Dict[str, Any]] = None
    slowQuery: Optional[bool] = None
    queryType: Optional[str] = None
    results: List[V1LoadResult]


class V1LoadRequestQueryFilterLogicalAnd(BaseModel):
    and_: Optional[List[Dict[str, Any]]] = Field(None, alias="and")


class V1LoadRequestQueryFilterLogicalOr(BaseModel):
    or_: Optional[List[Dict[str, Any]]] = Field(None, alias="or")


class V1LoadRequestQueryFilterBase(BaseModel):
    member: Optional[str] = None
    operator: Optional[str] = None
    values: Optional[List[str]] = None


class V1LoadRequestQueryTimeDimension(BaseModel):
    dimension: str
    granularity: Optional[str] = None
    dateRange: Optional[Union[str, List[str]]] = None


try:
    from pydantic import RootModel

    V1LoadRequestQueryFilterItem = RootModel[  # type: ignore
        Union[
            V1LoadRequestQueryFilterBase,
            V1LoadRequestQueryFilterLogicalOr,
            V1LoadRequestQueryFilterLogicalAnd,
        ]
    ]

except ImportError:

    class V1LoadRequestQueryFilterItem(BaseModel):  # type: ignore
        __root__: Union[
            V1LoadRequestQueryFilterBase,
            V1LoadRequestQueryFilterLogicalOr,
            V1LoadRequestQueryFilterLogicalAnd,
        ]


class V1LoadRequestQuery(BaseModel):
    measures: Optional[List[str]] = None
    dimensions: Optional[List[str]] = None
    segments: Optional[List[str]] = None
    timeDimensions: Optional[List[V1LoadRequestQueryTimeDimension]] = None
    order: Optional[List[List[str]]] = None
    limit: Optional[int] = None
    offset: Optional[int] = None
    filters: Optional[List[V1LoadRequestQueryFilterItem]] = None
    ungrouped: Optional[bool] = None


class V1LoadRequest(BaseModel):
    queryType: Optional[str] = None
    query: Optional[Union[V1LoadRequestQuery, List[V1LoadRequestQuery]]] = None


#############
# TypedDicts
#############


V1LoadRequestQueryFilterLogicalAndDict = TypedDict(
    "V1LoadRequestQueryFilterLogicalAndDict",
    {
        "and": NotRequired[List[Dict[str, Any]]],
    },
)


V1LoadRequestQueryFilterLogicalOrDict = TypedDict(
    "V1LoadRequestQueryFilterLogicalOrDict",
    {
        "or": NotRequired[List[Dict[str, Any]]],
    },
)


class V1LoadRequestQueryFilterBaseDict(TypedDict):
    member: NotRequired[str]
    operator: NotRequired[str]
    values: NotRequired[List[str]]


class V1LoadRequestQueryTimeDimensionDict(TypedDict):
    dimension: str
    granularity: NotRequired[str]
    dateRange: NotRequired[Union[str, List[str]]]


V1LoadRequestQueryFilterItemDict = Union[
    V1LoadRequestQueryFilterBaseDict,
    V1LoadRequestQueryFilterLogicalOrDict,
    V1LoadRequestQueryFilterLogicalAndDict,
]


class V1LoadRequestQueryDict(TypedDict):
    measures: NotRequired[List[str]]
    dimensions: NotRequired[List[str]]
    segments: NotRequired[List[str]]
    timeDimensions: NotRequired[List[V1LoadRequestQueryTimeDimensionDict]]
    order: NotRequired[List[List[str]]]
    limit: NotRequired[int]
    offset: NotRequired[int]
    filters: NotRequired[List[V1LoadRequestQueryFilterItemDict]]
    ungrouped: NotRequired[bool]
